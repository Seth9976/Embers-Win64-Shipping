// 函数: sub_1410b78a0
// 地址: 0x1410b78a0
// 来自: E:\Embers\Embers\Binaries\Win64\Embers-Win64-Shipping.exe

uint128_t zmm3 = zx.o(0)
int64_t* rcx = arg1[1].q

if (rcx != 0)
    (*(*rcx + 0x338))(rcx, arg5, arg3, zmm3)
    TEB* gsbase
    
    if (data_143cda914
            s> *(0x14 + *(gsbase->ThreadLocalStoragePointer + (zx.q(data_14401b1a0) << 3))))
        _Init_thread_header(&data_143cda914)
        
        if (data_143cda914 == 0xffffffff)
            data_143cda910 = 0x3fb8aa3b
            _Init_thread_footer(&data_143cda914)
    
    zmm3.d = logf(_mm_cvtepi32_ps(zx.o(int.d(arg4.d))).d).d f* data_143cda910
    zmm3.d = zmm3.d f+ 1f

arg4.d = zmm3.d f- 1f
*arg2 = *arg1
arg5.d = 1f f- 4f f/ zmm3.d
arg4.d = arg4.d f* arg5.d
arg2[1].d = arg5.d
*(arg2 + 0x14) = arg4.d
*(arg2 + 0x1c) = zmm3.d
arg4.d = 4f
arg5.d = zmm3.d f- arg4.d
*(arg2 + 0x18) = arg5.d
void* rcx_3 = arg1[1].q
void* rcx_4

if (rcx_3 == 0)
    rcx_4 = data_143f11688
else
    rcx_4 = *(rcx_3 + 0x78)

arg2[2].q = *(rcx_4 + 0x10)
int64_t result = *(rcx_4 + 0x18)
*(arg2 + 0x28) = result
return result
